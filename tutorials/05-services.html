<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Services - Connecting Your Applications | Complete Guide | K8s Tutorial #5</title>
    <link rel="stylesheet" href="../styles.css">
    <link rel="stylesheet" href="../blog-styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* Wider container for tutorials */
        .blog-post-detail {
            max-width: 1200px !important;
        }
        .blog-post-detail .container {
            max-width: 1200px !important;
        }
        .post-content {
            max-width: 100% !important;
        }
    </style>
</head>
<body>
    <!-- Navigation -->
    <nav class="navbar" id="navbar">
        <div class="container">
            <div class="nav-brand">
                <a href="../index.html">
                    <span class="brand-icon">âš¡</span>
                    DevSecOpsSolution<span class="highlight">.in</span>
                </a>
            </div>
            <button class="nav-toggle" id="navToggle">
                <span></span>
                <span></span>
                <span></span>
            </button>
            <ul class="nav-menu" id="navMenu">
                <li><a href="../index.html#home" class="nav-link">Home</a></li>
                <li><a href="../k8s-tutorials.html" class="nav-link">K8s Tutorials</a></li>
                <li><a href="../blog.html" class="nav-link">Blog</a></li>
                <li><a href="../index.html#contact" class="nav-link">Contact</a></li>
            </ul>
        </div>
    </nav>

    <!-- Blog Post Content -->
    <article class="blog-post-detail">
        <div class="container">
            <div class="post-header">
                <a href="../k8s-tutorials.html" class="back-link">
                    <i class="fas fa-arrow-left"></i> Back to Tutorials
                </a>
                <div class="post-icon">ğŸ”—</div>
                <h1 class="post-title">Services â€” Connecting Your Applications</h1>
                <div class="post-meta">
                    <span><i class="fas fa-bookmark"></i> Tutorial #5 of 20</span>
                    <span><i class="fas fa-signal"></i> Beginner to Intermediate</span>
                    <span><i class="far fa-clock"></i> 40 min read</span>
                    <span><i class="fas fa-code"></i> Hands-On Included</span>
                </div>
            </div>
            
            <div class="post-content">

                <h3 style="color: #667eea; margin-top: 0;">ğŸ¯ What You'll Learn</h3>
                <ul style="line-height: 2;">
                    <li>Why Kubernetes Services are essential (the pod IP problem)</li>
                    <li>How Services provide stable networking for dynamic pods</li>
                    <li>All Service types in depth: ClusterIP, NodePort, LoadBalancer, ExternalName, Headless</li>
                    <li>Service discovery mechanisms (DNS, environment variables)</li>
                    <li>Endpoints and EndpointSlices - how Services find Pods</li>
                    <li>Service networking internals (kube-proxy, iptables, IPVS)</li>
                    <li>Session affinity and traffic policies</li>
                    <li>Multi-port services and named ports</li>
                    <li>Service without selectors (external services)</li>
                    <li>Headless services for StatefulSets</li>
                    <li>Service mesh introduction (Istio, Linkerd)</li>
                    <li>Troubleshooting service connectivity</li>
                    <li>Best practices and real-world patterns</li>
                </ul>

                <h2>ğŸ¤” The Problem: Why Do We Need Services?</h2>

                <p>Imagine you have a frontend application that needs to talk to a backend API. In Kubernetes, both run as pods. But there's a fundamental problem...</p>

                <h3 style="color: #667eea;">The Pod IP Problem</h3>

                <div style="background: #742a2a; color: #fed7d7; padding: 25px; border-radius: 10px; margin: 20px 0;">
                    <h4 style="color: #fca5a5; margin-top: 0;">âŒ Problems with Direct Pod IPs:</h4>
                    <ul style="line-height: 2;">
                        <li><strong>Pods are ephemeral:</strong> They die and get recreated with new IPs</li>
                        <li><strong>Scaling changes IPs:</strong> Scale from 1 to 10 pods = 10 different IPs</li>
                        <li><strong>Rolling updates:</strong> New pods get new IPs during deployment</li>
                        <li><strong>No load balancing:</strong> How do you distribute traffic across replicas?</li>
                        <li><strong>Discovery nightmare:</strong> How does frontend find backend pods?</li>
                        <li><strong>No health awareness:</strong> Traffic might go to unhealthy pods</li>
                    </ul>
                </div>

                <div style="background: var(--dark-light); padding: 25px; border-radius: 10px; margin: 20px 0;">
                    <h4 style="color: #90cdf4;">Example Scenario:</h4>
                    <pre style="background: #2d3748; color: #e2e8f0; padding: 15px; border-radius: 5px; overflow-x: auto;"><code># You have 3 backend pods:
backend-pod-1: 10.244.1.5
backend-pod-2: 10.244.2.3
backend-pod-3: 10.244.3.7

# Frontend tries to connect:
frontend â†’ http://10.244.1.5:8080  # Works!

# But then backend-pod-1 crashes and restarts:
backend-pod-1: 10.244.1.12  # NEW IP!

# Frontend still trying old IP:
frontend â†’ http://10.244.1.5:8080  # FAILS! âŒ

# Problems:
# 1. Frontend doesn't know pod restarted
# 2. Frontend doesn't know new IP
# 3. Frontend doesn't know about other 2 pods
# 4. No automatic load balancing
# 5. Manual configuration nightmare</code></pre>
                </div>

                <h2>ğŸ”— Enter Kubernetes Services</h2>

                <p style="font-size: 1.1rem; line-height: 1.8;">A <strong>Service</strong> is an abstract way to expose an application running on a set of Pods as a network service. It provides a stable IP address and DNS name for a set of pods, with built-in load balancing.</p>

                <div style="background: #1c4532; color: #9ae6b4; padding: 25px; border-radius: 10px; margin: 20px 0;">
                    <h4 style="color: #9ae6b4; margin-top: 0;">âœ… What Services Provide:</h4>
                    <ul style="line-height: 2;">
                        <li><strong>Stable IP Address:</strong> Service IP never changes</li>
                        <li><strong>Stable DNS Name:</strong> Access via name (e.g., backend-service)</li>
                        <li><strong>Load Balancing:</strong> Automatic distribution across healthy pods</li>
                        <li><strong>Service Discovery:</strong> Pods can find each other by name</li>
                        <li><strong>Health Awareness:</strong> Only routes to ready pods</li>
                        <li><strong>Decoupling:</strong> Frontend doesn't need to know backend pod IPs</li>
                    </ul>
                </div>

                <div style="background: #2d3748; color: #e2e8f0; padding: 25px; border-radius: 10px; margin: 30px 0;">
                    <h3 style="color: #90cdf4; margin-top: 0;">How Services Work - High Level</h3>
                    <pre style="background: #1a202c; padding: 20px; border-radius: 5px; overflow-x: auto; font-size: 0.9rem;"><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Service Architecture                      â”‚
â”‚                                                              â”‚
â”‚  Frontend Pod                                               â”‚
â”‚     â”‚                                                        â”‚
â”‚     â”‚ Request: http://backend-service:8080                  â”‚
â”‚     â”‚                                                        â”‚
â”‚     â–¼                                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚           Service (backend-service)          â”‚          â”‚
â”‚  â”‚                                              â”‚          â”‚
â”‚  â”‚  Type: ClusterIP                             â”‚          â”‚
â”‚  â”‚  IP: 10.96.0.10 (stable, never changes)     â”‚          â”‚
â”‚  â”‚  DNS: backend-service.default.svc.cluster.localâ”‚        â”‚
â”‚  â”‚  Port: 8080                                  â”‚          â”‚
â”‚  â”‚  Selector: app=backend                       â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                     â”‚                                       â”‚
â”‚                     â”‚ (Load balances to)                    â”‚
â”‚                     â”‚                                       â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                          â”‚
â”‚         â”‚           â”‚           â”‚                          â”‚
â”‚         â–¼           â–¼           â–¼                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚  â”‚ Pod 1    â”‚ â”‚ Pod 2    â”‚ â”‚ Pod 3    â”‚                  â”‚
â”‚  â”‚ app=     â”‚ â”‚ app=     â”‚ â”‚ app=     â”‚                  â”‚
â”‚  â”‚ backend  â”‚ â”‚ backend  â”‚ â”‚ backend  â”‚                  â”‚
â”‚  â”‚          â”‚ â”‚          â”‚ â”‚          â”‚                  â”‚
â”‚  â”‚ 10.244.  â”‚ â”‚ 10.244.  â”‚ â”‚ 10.244.  â”‚                  â”‚
â”‚  â”‚ 1.5:8080 â”‚ â”‚ 2.3:8080 â”‚ â”‚ 3.7:8080 â”‚                  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
â”‚                                                              â”‚
â”‚  Pod IPs change â†’ Service IP stays the same âœ…              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>
                </div>


                <h2>ğŸ“‹ Service Types - Complete Guide</h2>

                <p>Kubernetes provides different Service types for different use cases. Let's explore each one in depth.</p>

                <h3 style="color: #667eea;">1. ClusterIP (Default) - Internal Communication</h3>

                <div style="background: var(--dark-light); padding: 25px; border-radius: 10px; margin: 20px 0;">
                    <p style="font-size: 1.1rem; line-height: 1.8;"><strong>Purpose:</strong> Exposes the Service on an internal IP within the cluster. This is the default type and makes the Service only reachable from within the cluster.</p>

                    <p><strong>Use Case:</strong> Internal microservice communication (frontend â†’ backend, backend â†’ database)</p>

                    <h4 style="color: #90cdf4; margin-top: 20px;">Complete Example:</h4>
                    <pre style="background: #2d3748; color: #e2e8f0; padding: 15px; border-radius: 5px; overflow-x: auto;"><code># backend-service.yaml
apiVersion: v1
kind: Service
metadata:
  name: backend-service
  namespace: default
  labels:
    app: backend
  annotations:
    description: "Backend API service"
spec:
  type: ClusterIP  # Default, can be omitted
  selector:
    app: backend
    tier: api
  ports:
  - name: http
    protocol: TCP
    port: 80          # Service port (what clients connect to)
    targetPort: 8080  # Pod port (where app listens)
  sessionAffinity: None  # or ClientIP for sticky sessions
  
# What happens:
# 1. Kubernetes assigns a ClusterIP (e.g., 10.96.0.10)
# 2. DNS entry created: backend-service.default.svc.cluster.local
# 3. kube-proxy creates iptables/IPVS rules
# 4. Traffic to 10.96.0.10:80 â†’ load balanced to pods on port 8080</code></pre>

                    <h4 style="color: #90cdf4; margin-top: 20px;">Accessing ClusterIP Service:</h4>
                    <pre style="background: #2d3748; color: #e2e8f0; padding: 15px; border-radius: 5px; overflow-x: auto;"><code># From within cluster (another pod):
curl http://backend-service:80
curl http://backend-service.default:80
curl http://backend-service.default.svc:80
curl http://backend-service.default.svc.cluster.local:80
curl http://10.96.0.10:80  # Direct IP

# From outside cluster:
# âŒ NOT accessible - ClusterIP is internal only

# To test from outside, use port-forward:
kubectl port-forward svc/backend-service 8080:80
# Then: curl http://localhost:8080</code></pre>

                    <h4 style="color: #90cdf4; margin-top: 20px;">ClusterIP Characteristics:</h4>
                    <ul style="line-height: 2;">
                        <li>âœ… Internal cluster communication only</li>
                        <li>âœ… Stable IP and DNS name</li>
                        <li>âœ… Load balancing across pods</li>
                        <li>âœ… Most common service type</li>
                        <li>âŒ Not accessible from outside cluster</li>
                    </ul>
                </div>

                <h3 style="color: #667eea;">2. NodePort - External Access via Node IP</h3>

                <div style="background: var(--dark-light); padding: 25px; border-radius: 10px; margin: 20px 0;">
                    <p style="font-size: 1.1rem; line-height: 1.8;"><strong>Purpose:</strong> Exposes the Service on each Node's IP at a static port (the NodePort). A ClusterIP Service is automatically created, and the NodePort Service routes to it.</p>

                    <p><strong>Use Case:</strong> Simple external access, development/testing, when LoadBalancer is not available</p>

                    <h4 style="color: #90cdf4; margin-top: 20px;">Complete Example:</h4>
                    <pre style="background: #2d3748; color: #e2e8f0; padding: 15px; border-radius: 5px; overflow-x: auto;"><code># frontend-service.yaml
apiVersion: v1
kind: Service
metadata:
  name: frontend-service
spec:
  type: NodePort
  selector:
    app: frontend
  ports:
  - name: http
    protocol: TCP
    port: 80          # ClusterIP port
    targetPort: 3000  # Pod port
    nodePort: 30080   # Node port (30000-32767 range)
                      # If omitted, Kubernetes assigns random port

# What happens:
# 1. ClusterIP created (e.g., 10.96.0.20)
# 2. Port 30080 opened on ALL nodes
# 3. Traffic to <any-node-ip>:30080 â†’ ClusterIP:80 â†’ pods:3000</code></pre>

                    <h4 style="color: #90cdf4; margin-top: 20px;">Accessing NodePort Service:</h4>
                    <pre style="background: #2d3748; color: #e2e8f0; padding: 15px; border-radius: 5px; overflow-x: auto;"><code># From outside cluster:
curl http://<node-1-ip>:30080
curl http://<node-2-ip>:30080
curl http://<node-3-ip>:30080
# All work! Traffic goes to same service

# From within cluster:
curl http://frontend-service:80  # ClusterIP still works
curl http://10.96.0.20:80        # Direct ClusterIP

# Get node IPs:
kubectl get nodes -o wide

# Example:
# node-1: 192.168.1.10
# node-2: 192.168.1.11
# node-3: 192.168.1.12
# Access: http://192.168.1.10:30080</code></pre>

                    <div style="background: #2d3748; color: #e2e8f0; padding: 20px; border-radius: 8px; margin-top: 15px;">
                        <h4 style="color: #90cdf4;">NodePort Traffic Flow:</h4>
                        <pre style="background: #1a202c; padding: 15px; border-radius: 5px; overflow-x: auto;"><code>External Client
     â”‚
     â”‚ http://192.168.1.10:30080
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Node 1       â”‚
â”‚   Port 30080   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”‚ (kube-proxy forwards to)
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ClusterIP: 10.96.0.20 â”‚
â”‚  Port: 80              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”‚ (Load balances to)
         â”‚
    â”Œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”
    â”‚    â”‚    â”‚
    â–¼    â–¼    â–¼
  Pod1 Pod2 Pod3
  :3000 :3000 :3000</code></pre>
                    </div>

                    <h4 style="color: #90cdf4; margin-top: 20px;">NodePort Characteristics:</h4>
                    <ul style="line-height: 2;">
                        <li>âœ… External access without cloud load balancer</li>
                        <li>âœ… Works on any Kubernetes cluster</li>
                        <li>âœ… Simple to set up</li>
                        <li>âš ï¸ Port range limited (30000-32767)</li>
                        <li>âš ï¸ Need to manage node IPs</li>
                        <li>âš ï¸ Not production-grade for public services</li>
                        <li>âš ï¸ No SSL termination</li>
                    </ul>

                    <div style="background: #744210; color: #fed7d7; padding: 15px; border-radius: 5px; margin-top: 15px;">
                        <strong>âš ï¸ Production Considerations:</strong>
                        <ul style="margin-top: 10px;">
                            <li>NodePort is typically used for development/testing</li>
                            <li>For production, use LoadBalancer or Ingress</li>
                            <li>If using NodePort in production, put a load balancer in front</li>
                        </ul>
                    </div>
                </div>

                <h3 style="color: #667eea;">3. LoadBalancer - Cloud Provider Integration</h3>

                <div style="background: var(--dark-light); padding: 25px; border-radius: 10px; margin: 20px 0;">
                    <p style="font-size: 1.1rem; line-height: 1.8;"><strong>Purpose:</strong> Exposes the Service externally using a cloud provider's load balancer. NodePort and ClusterIP Services are automatically created, and the external load balancer routes to them.</p>

                    <p><strong>Use Case:</strong> Production external access on cloud platforms (AWS, GCP, Azure)</p>

                    <h4 style="color: #90cdf4; margin-top: 20px;">Complete Example:</h4>
                    <pre style="background: #2d3748; color: #e2e8f0; padding: 15px; border-radius: 5px; overflow-x: auto;"><code># web-service.yaml
apiVersion: v1
kind: Service
metadata:
  name: web-service
  annotations:
    # AWS specific
    service.beta.kubernetes.io/aws-load-balancer-type: "nlb"
    service.beta.kubernetes.io/aws-load-balancer-ssl-cert: "arn:aws:acm:..."
    # GCP specific
    cloud.google.com/load-balancer-type: "Internal"
    # Azure specific
    service.beta.kubernetes.io/azure-load-balancer-internal: "true"
spec:
  type: LoadBalancer
  selector:
    app: web
  ports:
  - name: http
    protocol: TCP
    port: 80
    targetPort: 8080
  - name: https
    protocol: TCP
    port: 443
    targetPort: 8443
  loadBalancerSourceRanges:  # Restrict access
  - 203.0.113.0/24
  - 198.51.100.0/24
  externalTrafficPolicy: Local  # or Cluster (default)

# What happens:
# 1. ClusterIP created (e.g., 10.96.0.30)
# 2. NodePort created (e.g., 30123)
# 3. Cloud provider creates external load balancer
# 4. External LB â†’ NodePort â†’ ClusterIP â†’ Pods</code></pre>

                    <h4 style="color: #90cdf4; margin-top: 20px;">Accessing LoadBalancer Service:</h4>
                    <pre style="background: #2d3748; color: #e2e8f0; padding: 15px; border-radius: 5px; overflow-x: auto;"><code># Check service status:
kubectl get svc web-service

# Output:
# NAME          TYPE           CLUSTER-IP    EXTERNAL-IP      PORT(S)
# web-service   LoadBalancer   10.96.0.30    52.12.34.56      80:30123/TCP

# Access from internet:
curl http://52.12.34.56

# The EXTERNAL-IP is provided by cloud provider
# It may take 1-2 minutes to provision

# From within cluster:
curl http://web-service:80  # ClusterIP still works</code></pre>

                    <div style="background: #2d3748; color: #e2e8f0; padding: 20px; border-radius: 8px; margin-top: 15px;">
                        <h4 style="color: #90cdf4;">LoadBalancer Traffic Flow:</h4>
                        <pre style="background: #1a202c; padding: 15px; border-radius: 5px; overflow-x: auto;"><code>Internet Client
     â”‚
     â”‚ http://52.12.34.56
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Cloud Load Balancer    â”‚
â”‚  (AWS ELB/NLB, GCP LB)  â”‚
â”‚  IP: 52.12.34.56        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â”‚ (Distributes to)
           â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”
    â”‚      â”‚      â”‚
    â–¼      â–¼      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Node 1 â”‚â”‚ Node 2 â”‚â”‚ Node 3 â”‚
â”‚:30123  â”‚â”‚:30123  â”‚â”‚:30123  â”‚
â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
    â”‚         â”‚         â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
              â–¼
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚  ClusterIP    â”‚
      â”‚  10.96.0.30   â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
         â”Œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”
         â”‚    â”‚    â”‚
         â–¼    â–¼    â–¼
       Pod1 Pod2 Pod3</code></pre>
                    </div>

                    <h4 style="color: #90cdf4; margin-top: 20px;">externalTrafficPolicy Explained:</h4>
                    <pre style="background: #2d3748; color: #e2e8f0; padding: 15px; border-radius: 5px; overflow-x: auto;"><code># Cluster (default):
externalTrafficPolicy: Cluster
# - Traffic can be forwarded to any node
# - Source IP is lost (SNAT)
# - Better load distribution
# - Extra network hop possible

# Local:
externalTrafficPolicy: Local
# - Traffic only goes to node with pod
# - Source IP preserved
# - No extra network hop
# - Uneven load distribution if pods not on all nodes</code></pre>

                    <h4 style="color: #90cdf4; margin-top: 20px;">LoadBalancer Characteristics:</h4>
                    <ul style="line-height: 2;">
                        <li>âœ… Production-grade external access</li>
                        <li>âœ… Automatic SSL termination (with annotations)</li>
                        <li>âœ… Health checks</li>
                        <li>âœ… DDoS protection (cloud provider)</li>
                        <li>âš ï¸ Requires cloud provider</li>
                        <li>âš ï¸ Costs money (each LB = $$$)</li>
                        <li>âš ï¸ One LB per service (can get expensive)</li>
                    </ul>

                    <div style="background: #1c4532; color: #9ae6b4; padding: 15px; border-radius: 5px; margin-top: 15px;">
                        <strong>ğŸ’¡ Cost Optimization:</strong>
                        <p style="margin-top: 10px;">Instead of LoadBalancer per service, use:</p>
                        <ul>
                            <li><strong>Ingress:</strong> One LB for multiple services (Tutorial #13)</li>
                            <li><strong>API Gateway:</strong> Single entry point</li>
                            <li>Can save 80-90% on load balancer costs</li>
                        </ul>
                    </div>
                </div>


                <h3 style="color: #667eea;">4. ExternalName - DNS CNAME for External Services</h3>

                <div style="background: var(--dark-light); padding: 25px; border-radius: 10px; margin: 20px 0;">
                    <p style="font-size: 1.1rem; line-height: 1.8;"><strong>Purpose:</strong> Maps a Service to a DNS name (not to a set of pods). Returns a CNAME record with the external DNS name. No proxying of any kind is set up.</p>

                    <p><strong>Use Case:</strong> Access external services (databases, APIs) using Kubernetes service names</p>

                    <h4 style="color: #90cdf4; margin-top: 20px;">Complete Example:</h4>
                    <pre style="background: #2d3748; color: #e2e8f0; padding: 15px; border-radius: 5px; overflow-x: auto;"><code># external-db-service.yaml
apiVersion: v1
kind: Service
metadata:
  name: external-database
  namespace: default
spec:
  type: ExternalName
  externalName: database.example.com  # External DNS name
  ports:
  - port: 5432

# What happens:
# 1. No ClusterIP assigned
# 2. No kube-proxy rules created
# 3. DNS returns CNAME: external-database â†’ database.example.com
# 4. Client resolves database.example.com and connects directly</code></pre>

                    <h4 style="color: #90cdf4; margin-top: 20px;">Using ExternalName Service:</h4>
                    <pre style="background: #2d3748; color: #e2e8f0; padding: 15px; border-radius: 5px; overflow-x: auto;"><code># From pod:
psql -h external-database -p 5432 -U user

# DNS resolution:
# external-database.default.svc.cluster.local
#   â†’ CNAME database.example.com
#   â†’ A record 203.0.113.10
#   â†’ Connect to 203.0.113.10:5432

# Benefits:
# 1. Abstraction: Change external service without changing app code
# 2. Consistency: Use same service discovery pattern
# 3. Migration: Easy to migrate from external to internal service</code></pre>

                    <h4 style="color: #90cdf4; margin-top: 20px;">Migration Example:</h4>
                    <pre style="background: #2d3748; color: #e2e8f0; padding: 15px; border-radius: 5px; overflow-x: auto;"><code># Phase 1: External database
apiVersion: v1
kind: Service
metadata:
  name: database
spec:
  type: ExternalName
  externalName: rds.amazonaws.com

# Phase 2: Migrate to internal database
# Just change the service definition:
apiVersion: v1
kind: Service
metadata:
  name: database
spec:
  type: ClusterIP
  selector:
    app: postgres
  ports:
  - port: 5432

# Application code doesn't change!
# Still connects to: database:5432</code></pre>

                    <h4 style="color: #90cdf4; margin-top: 20px;">ExternalName Characteristics:</h4>
                    <ul style="line-height: 2;">
                        <li>âœ… Simple DNS CNAME mapping</li>
                        <li>âœ… No cluster resources used</li>
                        <li>âœ… Easy migration path</li>
                        <li>âŒ No load balancing</li>
                        <li>âŒ No health checks</li>
                        <li>âŒ Requires DNS resolution</li>
                    </ul>
                </div>

                <h3 style="color: #667eea;">5. Headless Services - Direct Pod Access</h3>

                <div style="background: var(--dark-light); padding: 25px; border-radius: 10px; margin: 20px 0;">
                    <p style="font-size: 1.1rem; line-height: 1.8;"><strong>Purpose:</strong> A Service without a ClusterIP. DNS returns the IP addresses of the pods directly instead of a single service IP. Used when you need to talk to specific pods.</p>

                    <p><strong>Use Case:</strong> StatefulSets, databases, peer discovery, custom load balancing</p>

                    <h4 style="color: #90cdf4; margin-top: 20px;">Complete Example:</h4>
                    <pre style="background: #2d3748; color: #e2e8f0; padding: 15px; border-radius: 5px; overflow-x: auto;"><code># headless-service.yaml
apiVersion: v1
kind: Service
metadata:
  name: cassandra
spec:
  clusterIP: None  # This makes it headless!
  selector:
    app: cassandra
  ports:
  - port: 9042
    name: cql

---
# StatefulSet using headless service
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: cassandra
spec:
  serviceName: cassandra  # Must match headless service name
  replicas: 3
  selector:
    matchLabels:
      app: cassandra
  template:
    metadata:
      labels:
        app: cassandra
    spec:
      containers:
      - name: cassandra
        image: cassandra:3.11
        ports:
        - containerPort: 9042
          name: cql

# What happens:
# 1. No ClusterIP assigned (clusterIP: None)
# 2. DNS returns ALL pod IPs
# 3. Each pod gets stable DNS name:
#    cassandra-0.cassandra.default.svc.cluster.local
#    cassandra-1.cassandra.default.svc.cluster.local
#    cassandra-2.cassandra.default.svc.cluster.local</code></pre>

                    <h4 style="color: #90cdf4; margin-top: 20px;">DNS Resolution:</h4>
                    <pre style="background: #2d3748; color: #e2e8f0; padding: 15px; border-radius: 5px; overflow-x: auto;"><code># Regular service DNS:
nslookup backend-service.default.svc.cluster.local
# Returns: 10.96.0.10 (single ClusterIP)

# Headless service DNS:
nslookup cassandra.default.svc.cluster.local
# Returns: 
# 10.244.1.5  (cassandra-0)
# 10.244.2.3  (cassandra-1)
# 10.244.3.7  (cassandra-2)

# Individual pod DNS:
nslookup cassandra-0.cassandra.default.svc.cluster.local
# Returns: 10.244.1.5 (specific pod)

# Use case: Connect to specific pod
psql -h cassandra-0.cassandra.default.svc.cluster.local</code></pre>

                    <h4 style="color: #90cdf4; margin-top: 20px;">When to Use Headless Services:</h4>
                    <ul style="line-height: 2;">
                        <li><strong>StatefulSets:</strong> Each pod needs stable network identity</li>
                        <li><strong>Databases:</strong> Connect to specific replica (master/slave)</li>
                        <li><strong>Peer Discovery:</strong> Pods need to find each other</li>
                        <li><strong>Custom Load Balancing:</strong> Client-side load balancing</li>
                        <li><strong>Distributed Systems:</strong> Cassandra, Kafka, Elasticsearch</li>
                    </ul>

                    <div style="background: #2d3748; color: #e2e8f0; padding: 20px; border-radius: 8px; margin-top: 15px;">
                        <h4 style="color: #90cdf4;">Headless vs Regular Service:</h4>
                        <pre style="background: #1a202c; padding: 15px; border-radius: 5px; overflow-x: auto;"><code>Regular Service (ClusterIP):
Client â†’ Service IP (10.96.0.10) â†’ Random Pod
         â””â”€ Load balancing by kube-proxy

Headless Service (clusterIP: None):
Client â†’ DNS lookup â†’ All Pod IPs
         â””â”€ Client chooses which pod
         â””â”€ No kube-proxy involvement</code></pre>
                    </div>
                </div>

                <h2>ğŸ” Service Discovery - How Pods Find Services</h2>

                <p>Kubernetes provides two primary mechanisms for service discovery: DNS and environment variables.</p>

                <h3 style="color: #667eea;">1. DNS-Based Discovery (Recommended)</h3>

                <div style="background: var(--dark-light); padding: 25px; border-radius: 10px; margin: 20px 0;">
                    <p>Kubernetes runs a DNS server (CoreDNS) that automatically creates DNS records for services.</p>

                    <h4 style="color: #90cdf4; margin-top: 20px;">DNS Record Format:</h4>
                    <pre style="background: #2d3748; color: #e2e8f0; padding: 15px; border-radius: 5px; overflow-x: auto;"><code># Full DNS name format:
<service-name>.<namespace>.svc.<cluster-domain>

# Examples:
backend-service.default.svc.cluster.local
frontend-service.production.svc.cluster.local
database.staging.svc.cluster.local

# Short forms (from same namespace):
backend-service
backend-service.default
backend-service.default.svc

# From different namespace:
backend-service.production  # Must include namespace</code></pre>

                    <h4 style="color: #90cdf4; margin-top: 20px;">DNS Resolution Examples:</h4>
                    <pre style="background: #2d3748; color: #e2e8f0; padding: 15px; border-radius: 5px; overflow-x: auto;"><code># Test DNS from pod:
kubectl run test --image=busybox:1.28 -it --rm -- sh

# Inside pod:
nslookup backend-service
# Returns: 10.96.0.10

nslookup backend-service.default.svc.cluster.local
# Returns: 10.96.0.10

# Check DNS configuration:
cat /etc/resolv.conf
# Output:
# nameserver 10.96.0.10  # CoreDNS service IP
# search default.svc.cluster.local svc.cluster.local cluster.local
# options ndots:5

# The search domains allow short names to work</code></pre>

                    <h4 style="color: #90cdf4; margin-top: 20px;">DNS for Different Service Types:</h4>
                    <pre style="background: #2d3748; color: #e2e8f0; padding: 15px; border-radius: 5px; overflow-x: auto;"><code># ClusterIP / NodePort / LoadBalancer:
nslookup my-service
# Returns: ClusterIP (e.g., 10.96.0.10)

# Headless Service:
nslookup my-headless-service
# Returns: All pod IPs
# 10.244.1.5
# 10.244.2.3
# 10.244.3.7

# ExternalName:
nslookup my-external-service
# Returns: CNAME to external DNS
# my-external-service â†’ database.example.com</code></pre>

                    <h4 style="color: #90cdf4; margin-top: 20px;">SRV Records for Named Ports:</h4>
                    <pre style="background: #2d3748; color: #e2e8f0; padding: 15px; border-radius: 5px; overflow-x: auto;"><code># Service with named ports:
apiVersion: v1
kind: Service
metadata:
  name: my-service
spec:
  ports:
  - name: http
    port: 80
  - name: https
    port: 443

# SRV records created:
_http._tcp.my-service.default.svc.cluster.local
_https._tcp.my-service.default.svc.cluster.local

# Query SRV record:
nslookup -type=SRV _http._tcp.my-service.default.svc.cluster.local
# Returns: Port and target information</code></pre>
                </div>

                <h3 style="color: #667eea;">2. Environment Variables (Legacy)</h3>

                <div style="background: var(--dark-light); padding: 25px; border-radius: 10px; margin: 20px 0;">
                    <p>Kubernetes automatically injects environment variables for services that exist when a pod is created.</p>

                    <h4 style="color: #90cdf4; margin-top: 20px;">Environment Variable Format:</h4>
                    <pre style="background: #2d3748; color: #e2e8f0; padding: 15px; border-radius: 5px; overflow-x: auto;"><code># For service named "backend-service":
BACKEND_SERVICE_SERVICE_HOST=10.96.0.10
BACKEND_SERVICE_SERVICE_PORT=80
BACKEND_SERVICE_PORT=tcp://10.96.0.10:80
BACKEND_SERVICE_PORT_80_TCP=tcp://10.96.0.10:80
BACKEND_SERVICE_PORT_80_TCP_PROTO=tcp
BACKEND_SERVICE_PORT_80_TCP_PORT=80
BACKEND_SERVICE_PORT_80_TCP_ADDR=10.96.0.10

# Check from pod:
kubectl exec my-pod -- env | grep BACKEND</code></pre>

                    <div style="background: #744210; color: #fed7d7; padding: 15px; border-radius: 5px; margin-top: 15px;">
                        <strong>âš ï¸ Environment Variable Limitations:</strong>
                        <ul style="margin-top: 10px;">
                            <li>Only injected for services that exist BEFORE pod creation</li>
                            <li>Pod restart required to get new services</li>
                            <li>Clutters environment</li>
                            <li>DNS is preferred method</li>
                        </ul>
                    </div>
                </div>


                <h2>ğŸ¯ Endpoints and EndpointSlices - The Connection</h2>

                <p>Services don't directly know about pods. The connection is made through Endpoints objects.</p>

                <h3 style="color: #667eea;">How Endpoints Work</h3>

                <div style="background: var(--dark-light); padding: 25px; border-radius: 10px; margin: 20px 0;">
                    <div style="background: #2d3748; color: #e2e8f0; padding: 20px; border-radius: 8px; margin-top: 15px;">
                        <pre style="background: #1a202c; padding: 15px; border-radius: 5px; overflow-x: auto;"><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            Service â†’ Endpoints â†’ Pods Flow                   â”‚
â”‚                                                              â”‚
â”‚  1. Create Service with selector                            â”‚
â”‚     apiVersion: v1                                          â”‚
â”‚     kind: Service                                           â”‚
â”‚     metadata:                                               â”‚
â”‚       name: backend-service                                 â”‚
â”‚     spec:                                                   â”‚
â”‚       selector:                                             â”‚
â”‚         app: backend  â† Selector                            â”‚
â”‚       ports:                                                â”‚
â”‚       - port: 80                                            â”‚
â”‚     â†“                                                        â”‚
â”‚  2. Endpoints Controller watches                            â”‚
â”‚     - Finds all pods matching selector (app=backend)        â”‚
â”‚     - Creates Endpoints object                              â”‚
â”‚     â†“                                                        â”‚
â”‚  3. Endpoints Object Created                                â”‚
â”‚     apiVersion: v1                                          â”‚
â”‚     kind: Endpoints                                         â”‚
â”‚     metadata:                                               â”‚
â”‚       name: backend-service  â† Same name as service         â”‚
â”‚     subsets:                                                â”‚
â”‚     - addresses:                                            â”‚
â”‚       - ip: 10.244.1.5  â† Pod 1 (Ready)                     â”‚
â”‚       - ip: 10.244.2.3  â† Pod 2 (Ready)                     â”‚
â”‚       notReadyAddresses:                                    â”‚
â”‚       - ip: 10.244.3.7  â† Pod 3 (Not Ready)                 â”‚
â”‚       ports:                                                â”‚
â”‚       - port: 8080                                          â”‚
â”‚     â†“                                                        â”‚
â”‚  4. kube-proxy watches Endpoints                            â”‚
â”‚     - Creates iptables/IPVS rules                           â”‚
â”‚     - Routes traffic to ready pod IPs only                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>
                    </div>

                    <h4 style="color: #90cdf4; margin-top: 20px;">View Endpoints:</h4>
                    <pre style="background: #2d3748; color: #e2e8f0; padding: 15px; border-radius: 5px; overflow-x: auto;"><code># List endpoints:
kubectl get endpoints

# Output:
# NAME              ENDPOINTS                                    AGE
# backend-service   10.244.1.5:8080,10.244.2.3:8080             5m
# frontend-service  10.244.1.6:3000,10.244.2.4:3000,10.244.3.8:3000  5m

# Describe endpoints:
kubectl describe endpoints backend-service

# Output:
# Name:         backend-service
# Namespace:    default
# Labels:       <none>
# Annotations:  endpoints.kubernetes.io/last-change-trigger-time: 2024-01-15T10:30:00Z
# Subsets:
#   Addresses:          10.244.1.5,10.244.2.3
#   NotReadyAddresses:  10.244.3.7
#   Ports:
#     Name     Port  Protocol
#     ----     ----  --------
#     <unset>  8080  TCP</code></pre>

                    <h4 style="color: #90cdf4; margin-top: 20px;">Endpoints vs EndpointSlices:</h4>
                    <pre style="background: #2d3748; color: #e2e8f0; padding: 15px; border-radius: 5px; overflow-x: auto;"><code># Endpoints (Legacy):
# - Single object per service
# - Can become large (1000+ endpoints)
# - Performance issues at scale
# - Max 1000 endpoints per object

# EndpointSlices (New, Kubernetes 1.17+):
# - Multiple slices per service
# - Each slice: max 100 endpoints
# - Better scalability
# - More efficient updates
# - Enabled by default in 1.21+

# View EndpointSlices:
kubectl get endpointslices

# Output:
# NAME                      ADDRESSTYPE   PORTS   ENDPOINTS               AGE
# backend-service-abc123    IPv4          8080    10.244.1.5,10.244.2.3   5m</code></pre>
                </div>

                <h3 style="color: #667eea;">Services Without Selectors</h3>

                <div style="background: var(--dark-light); padding: 25px; border-radius: 10px; margin: 20px 0;">
                    <p>You can create services without selectors and manually manage endpoints. Useful for external services or custom routing.</p>

                    <h4 style="color: #90cdf4; margin-top: 20px;">Example: External Database</h4>
                    <pre style="background: #2d3748; color: #e2e8f0; padding: 15px; border-radius: 5px; overflow-x: auto;"><code># Service without selector:
apiVersion: v1
kind: Service
metadata:
  name: external-db
spec:
  ports:
  - port: 5432
    targetPort: 5432
  # No selector!

---
# Manually create Endpoints:
apiVersion: v1
kind: Endpoints
metadata:
  name: external-db  # Must match service name
subsets:
- addresses:
  - ip: 192.168.1.100  # External database IP
  - ip: 192.168.1.101  # Backup database IP
  ports:
  - port: 5432

# Now pods can connect to external-db:5432
# Traffic goes to 192.168.1.100 or 192.168.1.101</code></pre>

                    <h4 style="color: #90cdf4; margin-top: 20px;">Use Cases:</h4>
                    <ul style="line-height: 2;">
                        <li>External databases (RDS, Cloud SQL)</li>
                        <li>Legacy systems</li>
                        <li>Services in other clusters</li>
                        <li>Custom load balancing logic</li>
                        <li>Migration scenarios</li>
                    </ul>
                </div>

                <h2>ğŸ’» Hands-On: Complete Service Examples</h2>

                <h3 style="color: #667eea;">Example 1: Multi-Tier Application</h3>

                <div style="background: #2d3748; color: #e2e8f0; padding: 25px; border-radius: 10px; margin: 30px 0;">
                    <p><strong>Scenario:</strong> Frontend â†’ Backend â†’ Database</p>

                    <pre style="background: #1a202c; padding: 15px; border-radius: 5px; overflow-x: auto;"><code># 1. Database (Headless Service for StatefulSet)
apiVersion: v1
kind: Service
metadata:
  name: postgres
spec:
  clusterIP: None  # Headless
  selector:
    app: postgres
  ports:
  - port: 5432
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: postgres
spec:
  serviceName: postgres
  replicas: 1
  selector:
    matchLabels:
      app: postgres
  template:
    metadata:
      labels:
        app: postgres
    spec:
      containers:
      - name: postgres
        image: postgres:14
        ports:
        - containerPort: 5432
        env:
        - name: POSTGRES_PASSWORD
          value: secret

---
# 2. Backend API (ClusterIP Service)
apiVersion: v1
kind: Service
metadata:
  name: backend-api
spec:
  type: ClusterIP
  selector:
    app: backend
  ports:
  - port: 8080
    targetPort: 8080
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend
spec:
  replicas: 3
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
      - name: backend
        image: myapp/backend:1.0
        ports:
        - containerPort: 8080
        env:
        - name: DATABASE_URL
          value: "postgres://postgres:5432/mydb"  # Uses service DNS

---
# 3. Frontend (LoadBalancer Service)
apiVersion: v1
kind: Service
metadata:
  name: frontend
spec:
  type: LoadBalancer
  selector:
    app: frontend
  ports:
  - port: 80
    targetPort: 3000
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend
spec:
  replicas: 2
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
    spec:
      containers:
      - name: frontend
        image: myapp/frontend:1.0
        ports:
        - containerPort: 3000
        env:
        - name: BACKEND_URL
          value: "http://backend-api:8080"  # Uses service DNS</code></pre>

                    <p><strong>Deploy and test:</strong></p>
                    <pre style="background: #1a202c; padding: 15px; border-radius: 5px; overflow-x: auto;"><code># Apply all resources:
kubectl apply -f multi-tier-app.yaml

# Check services:
kubectl get svc

# Check endpoints:
kubectl get endpoints

# Test connectivity from frontend to backend:
kubectl exec -it frontend-xxx -- curl http://backend-api:8080/health

# Test connectivity from backend to database:
kubectl exec -it backend-xxx -- psql -h postgres -U postgres

# Access frontend from browser:
kubectl get svc frontend
# Use EXTERNAL-IP</code></pre>
                </div>

                <h3 style="color: #667eea;">Example 2: Multi-Port Service</h3>

                <div style="background: #2d3748; color: #e2e8f0; padding: 25px; border-radius: 10px; margin: 30px 0;">
                    <pre style="background: #1a202c; padding: 15px; border-radius: 5px; overflow-x: auto;"><code># Service with multiple ports:
apiVersion: v1
kind: Service
metadata:
  name: web-service
spec:
  selector:
    app: web
  ports:
  - name: http
    port: 80
    targetPort: 8080
    protocol: TCP
  - name: https
    port: 443
    targetPort: 8443
    protocol: TCP
  - name: metrics
    port: 9090
    targetPort: 9090
    protocol: TCP

# Access different ports:
curl http://web-service:80      # HTTP
curl https://web-service:443    # HTTPS
curl http://web-service:9090/metrics  # Metrics</code></pre>
                </div>

                <h3 style="color: #667eea;">Example 3: Session Affinity</h3>

                <div style="background: #2d3748; color: #e2e8f0; padding: 25px; border-radius: 10px; margin: 30px 0;">
                    <pre style="background: #1a202c; padding: 15px; border-radius: 5px; overflow-x: auto;"><code># Service with session affinity (sticky sessions):
apiVersion: v1
kind: Service
metadata:
  name: stateful-app
spec:
  selector:
    app: stateful
  sessionAffinity: ClientIP  # Stick to same pod
  sessionAffinityConfig:
    clientIP:
      timeoutSeconds: 10800  # 3 hours
  ports:
  - port: 80
    targetPort: 8080

# How it works:
# 1. Client 192.168.1.100 connects
# 2. Routed to pod-1 (10.244.1.5)
# 3. All subsequent requests from 192.168.1.100 go to pod-1
# 4. For 3 hours (or until pod dies)

# Use cases:
# - Shopping carts (session data)
# - WebSocket connections
# - Stateful applications</code></pre>
                </div>

                <h2>ğŸ› Troubleshooting Services</h2>

                <div style="background: var(--dark-light); padding: 25px; border-radius: 10px; margin: 20px 0;">
                    <h4 style="color: #90cdf4;">Common Issues and Solutions:</h4>

                    <p><strong>Issue 1: Service has no endpoints</strong></p>
                    <pre style="background: #2d3748; color: #e2e8f0; padding: 15px; border-radius: 5px; overflow-x: auto;"><code># Check endpoints:
kubectl get endpoints my-service

# If empty:
# NAME         ENDPOINTS   AGE
# my-service   <none>      5m

# Causes:
# 1. No pods match selector
# 2. Pods not ready
# 3. Selector mismatch

# Debug:
# Check service selector:
kubectl get svc my-service -o yaml | grep -A 5 selector

# Check pod labels:
kubectl get pods --show-labels

# Check pod readiness:
kubectl get pods
kubectl describe pod <pod-name>

# Fix: Ensure pod labels match service selector</code></pre>

                    <p><strong>Issue 2: Cannot connect to service</strong></p>
                    <pre style="background: #2d3748; color: #e2e8f0; padding: 15px; border-radius: 5px; overflow-x: auto;"><code># Test from another pod:
kubectl run test --image=busybox:1.28 -it --rm -- sh

# Inside test pod:
wget -O- http://my-service:80
# or
nc -zv my-service 80

# If fails:
# 1. Check service exists:
kubectl get svc my-service

# 2. Check DNS resolution:
nslookup my-service

# 3. Check endpoints:
kubectl get endpoints my-service

# 4. Check pod is listening:
kubectl exec <pod-name> -- netstat -tlnp

# 5. Check network policies:
kubectl get networkpolicies

# 6. Check kube-proxy:
kubectl get pods -n kube-system | grep kube-proxy
kubectl logs -n kube-system kube-proxy-xxx</code></pre>

                    <p><strong>Issue 3: LoadBalancer stuck in Pending</strong></p>
                    <pre style="background: #2d3748; color: #e2e8f0; padding: 15px; border-radius: 5px; overflow-x: auto;"><code># Check service:
kubectl get svc my-service

# Output:
# NAME         TYPE           EXTERNAL-IP   PORT(S)
# my-service   LoadBalancer   <pending>     80:30123/TCP

# Causes:
# 1. Not on cloud provider (minikube, kind)
# 2. Cloud provider integration not configured
# 3. Quota limits reached
# 4. Cloud provider error

# Solutions:
# On minikube:
minikube tunnel  # Provides LoadBalancer IPs

# On kind:
# Use MetalLB or NodePort instead

# On cloud:
# Check cloud provider logs
kubectl describe svc my-service
# Look for events</code></pre>

                    <p><strong>Issue 4: Traffic not load balanced</strong></p>
                    <pre style="background: #2d3748; color: #e2e8f0; padding: 15px; border-radius: 5px; overflow-x: auto;"><code># Check if session affinity is enabled:
kubectl get svc my-service -o yaml | grep sessionAffinity

# If sessionAffinity: ClientIP
# All requests from same client go to same pod

# Check kube-proxy mode:
kubectl logs -n kube-system kube-proxy-xxx | grep "proxy mode"

# Test load balancing:
for i in {1..10}; do
  kubectl exec test-pod -- curl -s http://my-service | grep hostname
done

# Should see different pod names</code></pre>
                </div>


                <h2>âœ… Best Practices</h2>

                <div style="background: #1c4532; color: #9ae6b4; padding: 25px; border-radius: 10px; margin: 30px 0;">
                    <h3 style="color: #9ae6b4; margin-top: 0;">Service Design Best Practices</h3>
                    <ol style="line-height: 2; font-size: 1.05rem;">
                        <li>âœ… <strong>Use DNS names, not IPs:</strong> Always use service names (backend-service) not ClusterIPs</li>
                        <li>âœ… <strong>Name your ports:</strong> Use named ports for clarity and flexibility</li>
                        <li>âœ… <strong>Use readiness probes:</strong> Ensure only healthy pods receive traffic</li>
                        <li>âœ… <strong>Choose right service type:</strong>
                            <ul>
                                <li>ClusterIP: Internal communication (default)</li>
                                <li>NodePort: Development/testing</li>
                                <li>LoadBalancer: Production external access</li>
                                <li>Ingress: Multiple services (preferred for HTTP/HTTPS)</li>
                            </ul>
                        </li>
                        <li>âœ… <strong>Use Ingress over LoadBalancer:</strong> Save costs, one LB for many services</li>
                        <li>âœ… <strong>Headless for StatefulSets:</strong> When you need stable pod identities</li>
                        <li>âœ… <strong>Session affinity carefully:</strong> Only when truly needed (stateful apps)</li>
                        <li>âœ… <strong>Monitor endpoints:</strong> Alert when endpoints are empty</li>
                        <li>âœ… <strong>Use namespaces:</strong> Organize services by environment/team</li>
                        <li>âœ… <strong>Document service dependencies:</strong> Know which services talk to which</li>
                        <li>âœ… <strong>Set resource limits:</strong> On pods behind services</li>
                        <li>âœ… <strong>Use network policies:</strong> Restrict which pods can access services</li>
                    </ol>
                </div>

                <h3 style="color: #667eea;">Service Naming Conventions</h3>

                <div style="background: var(--dark-light); padding: 25px; border-radius: 10px; margin: 20px 0;">
                    <pre style="background: #2d3748; color: #e2e8f0; padding: 15px; border-radius: 5px; overflow-x: auto;"><code># Good naming patterns:
backend-api          # Clear purpose
frontend-web         # Clear purpose
postgres-primary     # Indicates role
redis-cache          # Indicates use
user-service         # Domain-based
payment-service      # Domain-based

# Avoid:
service1             # Not descriptive
my-service           # Too generic
svc-backend          # Redundant prefix
backend_api          # Use hyphens, not underscores</code></pre>
                </div>

                <h3 style="color: #667eea;">Performance Considerations</h3>

                <div style="background: var(--dark-light); padding: 25px; border-radius: 10px; margin: 20px 0;">
                    <ul style="line-height: 2;">
                        <li><strong>Use IPVS mode:</strong> Better performance for large clusters (1000+ services)</li>
                        <li><strong>Minimize service hops:</strong> Direct pod-to-pod when possible</li>
                        <li><strong>Use headless services:</strong> For client-side load balancing</li>
                        <li><strong>Monitor service latency:</strong> Track p50, p95, p99</li>
                        <li><strong>Use connection pooling:</strong> Reuse connections to services</li>
                        <li><strong>Consider service mesh:</strong> For advanced traffic management (Istio, Linkerd)</li>
                    </ul>
                </div>

                <h3 style="color: #667eea;">Security Best Practices</h3>

                <div style="background: var(--dark-light); padding: 25px; border-radius: 10px; margin: 20px 0;">
                    <pre style="background: #2d3748; color: #e2e8f0; padding: 15px; border-radius: 5px; overflow-x: auto;"><code># 1. Use Network Policies to restrict access:
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: backend-policy
spec:
  podSelector:
    matchLabels:
      app: backend
  policyTypes:
  - Ingress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: frontend  # Only frontend can access backend
    ports:
    - protocol: TCP
      port: 8080

# 2. Use TLS for sensitive services:
# - Terminate TLS at Ingress
# - Or use service mesh for mTLS

# 3. Restrict LoadBalancer source ranges:
spec:
  type: LoadBalancer
  loadBalancerSourceRanges:
  - 203.0.113.0/24  # Only allow from specific IPs

# 4. Use separate namespaces:
# - production namespace
# - staging namespace
# - development namespace

# 5. Implement authentication:
# - API keys
# - OAuth/OIDC
# - Service mesh identity</code></pre>
                </div>

                <h2>ğŸ¯ Key Takeaways</h2>

                <div style="background: #1c4532; color: #9ae6b4; padding: 25px; border-radius: 10px; margin: 30px 0;">
                    <ul style="line-height: 2; font-size: 1.05rem;">
                        <li>âœ… <strong>Services provide stable networking</strong> for ephemeral pods</li>
                        <li>âœ… <strong>ClusterIP</strong> is default, for internal communication</li>
                        <li>âœ… <strong>NodePort</strong> exposes on node IPs (dev/test)</li>
                        <li>âœ… <strong>LoadBalancer</strong> creates cloud LB (production)</li>
                        <li>âœ… <strong>ExternalName</strong> is DNS CNAME to external services</li>
                        <li>âœ… <strong>Headless services</strong> return pod IPs directly</li>
                        <li>âœ… <strong>DNS is the primary</strong> service discovery mechanism</li>
                        <li>âœ… <strong>Endpoints connect</strong> services to pods</li>
                        <li>âœ… <strong>kube-proxy implements</strong> service networking</li>
                        <li>âœ… <strong>Use Ingress</strong> instead of multiple LoadBalancers</li>
                        <li>âœ… <strong>Readiness probes</strong> ensure traffic goes to healthy pods</li>
                        <li>âœ… <strong>Services are fundamental</strong> to Kubernetes networking</li>
                    </ul>
                </div>

                <h2>ğŸš€ What's Next?</h2>

                <p>Now that you understand Services and how pods communicate, you're ready to learn about Deployments - the recommended way to manage and update your applications in Kubernetes!</p>

                <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 30px; border-radius: 10px; color: white; text-align: center; margin: 40px 0;">
                    <h3 style="color: white; margin-top: 0;">Ready to manage application rollouts?</h3>
                    <a href="06-deployments.html" style="display: inline-block; background: var(--dark-light); color: #667eea; padding: 15px 40px; border-radius: 8px; text-decoration: none; font-weight: 600; margin-top: 15px;">
                        Tutorial #6: Deployments - Managing Application Rollouts â†’
                    </a>
                </div>

                <hr style="margin: 40px 0;">
                
                <div style="text-align: center; color: #718096;">
                    <p>Questions or feedback? Connect with me on <a href="https://www.linkedin.com/in/saransh-jain13/" target="_blank" style="color: #667eea;">LinkedIn</a> or <a href="https://github.com/Saransh138" target="_blank" style="color: #667eea;">GitHub</a>!</p>
                </div>
            </div>
        </div>
    </article>

    <!-- Footer -->
    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <div class="footer-brand">
                    <h3><span class="brand-icon">âš¡</span> DevSecOpsSolution<span class="highlight">.in</span></h3>
                    <p>Building secure, scalable cloud solutions</p>
                </div>
                <div class="footer-links">
                    <h4>Quick Links</h4>
                    <ul>
                        <li><a href="../index.html#home">Home</a></li>
                        <li><a href="../k8s-tutorials.html">K8s Tutorials</a></li>
                        <li><a href="../blog.html">Blog</a></li>
                    </ul>
                </div>
                <div class="footer-social">
                    <h4>Connect</h4>
                    <div class="social-links">
                        <a href="https://github.com/Saransh138" target="_blank"><i class="fab fa-github"></i></a>
                        <a href="https://www.linkedin.com/in/saransh-jain13/" target="_blank"><i class="fab fa-linkedin"></i></a>
                    </div>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2024 DevSecOps Solutions. All rights reserved.</p>
            </div>
        </div>
    </footer>

    <script src="../script.js"></script>
</body>
</html>
